---
title: Java Web框架
date: 2025-11-19 15:28:11
categories:
  - 学习笔记
tags:
  - Java
---

# 前言
在学习Spring Boot时了解到这是一个整合Web/持久层(持久层框架（如MyBatis/Hibernate）属于数据访问层组件，与Web框架是协作关系而非包含关系。)的全栈框架，但对于各种框架的含义仍缺乏了解，故在此系统梳理一下。

# 框架

## 定义
Java Web框架是封装好的专为构建Web应用的代码骨架，为开发者提供标准化的开发基础。在框架中预先写好了许多基础或底层功能，让开发者可以在开发时避免在这些琐碎的方面浪费时间，专心于业务逻辑和核心代码构建。
## 核心功能
1.提升开发效率。 框架可以通过调用接口等方式自动化处理如数据库操作、HTTP请求解析等重复性任务。

2.生态整合。 一些框架会集成数据库、缓存、消息队列等第三方组件，不需要开发者进行二次引入(SpringBoot自带Tomcat)。

3.提高维护性。 模块化设计降低代码耦合度，便于后期扩展。

# 分类
## 架构风格分类
### 1. 传统 MVC 框架
* **代表框架：** Spring MVC, Struts2 (已过时)
* **特点：** 基于 Servlet 规范，采用同步阻塞 I/O 模型。严格遵循 Model-View-Controller 分层设计，强调职责分离。通常配合 JSP、Thymeleaf 等模板引擎进行服务端渲染 (SSR)。
* **适用于：** 传统的企业级单体应用、后台管理系统、SEO 友好的门户网站。

### 2. 微框架 (Micro-frameworks)
* **代表框架：** Javalin, Spark Java, Blade
* **特点：** 极简设计 (核心库往往 <1MB)，不强制特定的项目结构。去除了复杂的依赖注入和繁重的配置，专注于提供轻量级的 HTTP 路由和 API 处理。
* **适用于：** 轻量级微服务、简单的 RESTful API、原型快速开发、教学演示。

### 3. 云原生框架 (Cloud-Native)
* **代表框架：** Quarkus, Micronaut, Helidon
* **特点：** “为云而生”。通过编译时依赖注入 (Compile-time DI) 和 AOT (Ahead-of-Time) 预编译技术，显著减少内存占用和启动时间。完美适配 Kubernetes 环境，且对 GraalVM 原生镜像有极佳支持。
* **适用于：** Serverless (无服务器架构)、高密度部署的容器化微服务、对启动速度和内存有严格要求的场景 (如 AWS Lambda)。

### 4. 响应式框架 (Reactive)
* **代表框架：** Spring WebFlux, Vert.x
* **特点：** 基于 Netty 等非阻塞服务器，采用异步非阻塞 I/O 模型和事件驱动架构。能够以少量的线程处理极高的并发请求，背压 (Backpressure) 机制保证系统稳定性。
* **适用于：** 高并发系统 (如网关、社交 IM)、I/O 密集型应用、实时数据流处理。


## 按部署形态分类
### 1. 嵌入式服务器框架
* **代表：** Spring Boot
* **形态：** 内嵌 Tomcat/Jetty/Undertow(4里取消支持Undertow了，不知道未来会不会支持，先插个眼) 容器。
* **特点：** 打包为可执行的 Fat JAR，`java -jar` 即可运行，不再依赖外部 Web 容器。
* **性能：** 启动时间通常在 1-5 秒，开发体验极佳。

### 2. GraalVM 原生框架
* **代表：** Quarkus Native, Micronaut Native
* **形态：** 经 GraalVM 编译为本地机器码 (Binary)。
* **特点：** 启动速度极快 (<50ms)，内存占用极低 (<30MB)，但构建 (Build) 时间较长，且反射机制受限。
* **性能：** “冷启动”几乎消失，非常适合 Serverless。

### 3. 传统 WAR 部署框架
* **代表：** JSF + WebLogic/JBoss
* **形态：** 打包为 WAR 文件，需部署到独立的外部应用服务器中。
* **特点：** 配置繁琐，依赖服务器环境，且应用服务器本身启动沉重。
* **现状：** 主要存在于遗留系统 (Legacy Systems) 中，新项目已很少采用。